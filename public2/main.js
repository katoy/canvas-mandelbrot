// Generated by CoffeeScript 1.6.2
"use strict";
var DragBox, OSC, OSG, canvas, changeMaxIterations, changePaletteLength, changeStretchPalette, changeWorkerCount, createPalette, doDraw, dragbox, dx, dy, fixedPaletteLength, graphics, job, jobFinished, jobNum, jobs, jobsCompleted, makeSpectralColor, maxIterations, newWorkers, palette, paletteLength, repaint, repaintTimeout, running, setDefaults, setLimits, setUpDragging, startJob, stopJob, stretchPalette, workerCount, workers, xmax, xmin, ymax, ymin;

workers = null;

workerCount = null;

jobNum = 0;

running = false;

repaintTimeout = null;

xmin = null;

ymin = null;

xmax = null;

ymax = null;

dx = null;

dy = null;

jobs = null;

jobsCompleted = null;

OSC = null;

OSG = null;

canvas = null;

graphics = null;

dragbox = null;

maxIterations = null;

stretchPalette = true;

fixedPaletteLength = 250;

paletteLength = null;

palette = null;

job = null;

newWorkers = function(count) {
  var i, _results;

  i = 0;
  if (workers) {
    i = 0;
    while (i < workerCount) {
      workers[i].terminate();
      i++;
    }
  }
  workers = [];
  workerCount = count;
  i = 0;
  _results = [];
  while (i < workerCount) {
    workers[i] = new Worker("MandelbrotWorker.js");
    workers[i].onmessage = jobFinished;
    _results.push(i++);
  }
  return _results;
};

setLimits = function(x1, x2, y1, y2) {
  var aspect, center, height, newHeight, newWidth, temp, width, windowAspect;

  xmin = x1;
  xmax = x2;
  ymin = y1;
  ymax = y2;
  if (xmax < xmin) {
    temp = xmin;
    xmin = xmax;
    xmax = temp;
  }
  if (ymax < ymin) {
    temp = ymax;
    ymax = ymin;
    ymin = temp;
  }
  width = xmax - xmin;
  height = ymax - ymin;
  aspect = width / height;
  windowAspect = canvas.width / canvas.height;
  if (aspect < windowAspect) {
    newWidth = width * windowAspect / aspect;
    center = (xmax + xmin) / 2;
    xmax = center + newWidth / 2;
    xmin = center - newWidth / 2;
  } else if (aspect > windowAspect) {
    newHeight = height * aspect / windowAspect;
    center = (ymax + ymin) / 2;
    ymax = center + newHeight / 2;
    ymin = center - newHeight / 2;
  }
  dx = (xmax - xmin) / (canvas.width - 1);
  return dy = (ymax - ymin) / (canvas.height - 1);
};

doDraw = function() {
  graphics.drawImage(OSC, 0, 0);
  if (dragbox && dragbox.width > 2 && dragbox.height > 2) {
    return dragbox.draw();
  }
};

repaint = function() {
  doDraw();
  if (running) {
    repaintTimeout = setTimeout(repaint, 500);
    return $("#message").html("Computing...  Completed " + jobsCompleted + " of " + canvas.height + " rows");
  } else {
    return $("#message").html("Idle");
  }
};

stopJob = function() {
  if (running) {
    jobNum++;
    running = false;
    if (repaintTimeout) {
      clearTimeout(repaintTimeout);
    }
    repaintTimeout = null;
    return repaint();
  }
};

startJob = function() {
  var columns, i, j, row, rows, y;

  if (running) {
    stopJob();
  }
  graphics.fillRect(0, 0, canvas.width, canvas.height);
  OSG.fillStyle = "#BBB";
  OSG.fillRect(0, 0, canvas.width, canvas.height);
  jobs = [];
  y = ymax;
  rows = canvas.height;
  columns = canvas.width;
  row = 0;
  while (row < rows) {
    jobs[rows - 1 - row] = {
      jobNum: jobNum,
      row: row,
      maxIterations: maxIterations,
      y: y,
      xmin: xmin,
      columns: columns,
      dx: dx
    };
    y -= dy;
    row++;
  }
  jobsCompleted = 0;
  i = 0;
  while (i < workerCount) {
    j = jobs.pop();
    j.workerNum = i;
    workers[i].postMessage(j);
    i++;
  }
  running = true;
  $("#message").html("Computing...");
  return repaintTimeout = setTimeout(repaint, 333);
};

jobFinished = function(msg) {
  var col, columns, ct, iterationCounts, j, paletteIndex, row, worker;

  job = msg.data;
  if (job.jobNum !== jobNum) {
    return;
  }
  iterationCounts = job.iterationCounts;
  row = job.row;
  columns = canvas.width;
  col = 0;
  while (col < columns) {
    ct = iterationCounts[col];
    paletteIndex = 0;
    if (ct < 0) {
      OSG.fillStyle = "#000";
    } else {
      paletteIndex = iterationCounts[col] % paletteLength;
      OSG.fillStyle = palette[paletteIndex];
    }
    OSG.fillRect(col, row, 1, 1);
    col++;
  }
  jobsCompleted++;
  if (jobsCompleted === canvas.height) {
    return stopJob();
  } else if (jobs.length > 0) {
    worker = workers[job.workerNum];
    j = jobs.pop();
    j.workerNum = job.workerNum;
    return worker.postMessage(j);
  }
};

setDefaults = function() {
  stopJob();
  setLimits(-2.2, 0.8, -1.2, 1.2);
  stretchPalette = true;
  fixedPaletteLength = 250;
  maxIterations = 100;
  createPalette();
  $("#stretchPaletteCheckbox").attr("checked", true);
  $("#paletteLengthPar").css("display", "none");
  $("#maxIterSelect").val(100);
  $("#otherMaxIter").html("&nbsp;");
  $("#paletteLengthSelect").val("250");
  $("#otherPaletteLength").html("&nbsp;");
  return startJob();
};

makeSpectralColor = function(hue) {
  var b, bx, color, fraction, g, gx, r, rx, section;

  section = Math.floor(hue * 6);
  fraction = hue * 6 - section;
  r = 0;
  g = 0;
  b = 0;
  switch (section) {
    case 0:
      r = 1;
      g = fraction;
      b = 0;
      break;
    case 1:
      r = 1 - fraction;
      g = 1;
      b = 0;
      break;
    case 2:
      r = 0;
      g = 1;
      b = fraction;
      break;
    case 3:
      r = 0;
      g = 1 - fraction;
      b = 1;
      break;
    case 4:
      r = fraction;
      g = 0;
      b = 1;
      break;
    case 5:
      r = 1;
      g = 0;
      b = 1 - fraction;
  }
  rx = new Number(Math.floor(r * 255)).toString(16);
  if (rx.length === 1) {
    rx = "0" + rx;
  }
  gx = new Number(Math.floor(g * 255)).toString(16);
  if (gx.length === 1) {
    gx = "0" + gx;
  }
  bx = new Number(Math.floor(b * 255)).toString(16);
  if (bx.length === 1) {
    bx = "0" + bx;
  }
  color = "#" + rx + gx + bx;
  return color;
};

createPalette = function() {
  var hue, i, length, _results;

  length = (stretchPalette ? maxIterations : fixedPaletteLength);
  if (length === paletteLength) {
    return;
  }
  paletteLength = length;
  palette = [];
  i = 0;
  _results = [];
  while (i < paletteLength) {
    hue = i / paletteLength;
    palette[i] = makeSpectralColor(hue);
    _results.push(i++);
  }
  return _results;
};

DragBox = function(x, y) {
  this.x = this.left = x;
  this.y = this.top = y;
  this.width = 0;
  return this.height = 0;
};

setUpDragging = function() {
  var zoomin;

  zoomin = 0;
  dragbox = null;
  $("#mbcanvas").mousedown(function(e) {
    var offset, x, y;

    if (dragbox || e.button !== 0) {
      return;
    }
    offset = $("#mbcanvas").offset();
    x = Math.round(e.pageX - offset.left);
    y = Math.round(e.pageY - offset.top);
    dragbox = new DragBox(x, y);
    zoomin = !e.shiftKey;
    return doDraw();
  });
  $("#mbcanvas").mousemove(function(e) {
    var offset, x, y;

    if (dragbox) {
      offset = $("#mbcanvas").offset();
      x = Math.round(e.pageX - offset.left);
      y = Math.round(e.pageY - offset.top);
      dragbox.setCorner(x, y);
      return doDraw();
    }
  });
  return $(document).mouseup(function() {
    if (dragbox) {
      dragbox.zoom(zoomin);
      return dragbox = null;
    }
  });
};

changeWorkerCount = function() {
  var ct;

  ct = parseInt($("#threadCountSelect").val());
  if (ct === workerCount) {
    return;
  }
  stopJob();
  newWorkers(ct);
  return startJob();
};

changeMaxIterations = function() {
  var iter, val;

  val = $("#maxIterSelect").val();
  iter = 0;
  if (val === "Other...") {
    val = prompt("Enter the maximum number of iterations", maxIterations);
    iter = parseInt(val);
    if (isNaN(iter) || iter < 1 || iter > 100000) {
      alert("Sorry, the value must be a positive integer, and not more than 100000.");
      $("#maxIterSelect").val(maxIterations);
      return;
    }
    $("#otherMaxIter").html("(" + iter + ")");
  } else {
    iter = parseInt(val);
    $("#otherMaxIter").html("&nbsp;");
  }
  if (iter === maxIterations) {
    return;
  }
  maxIterations = iter;
  createPalette();
  return startJob();
};

changeStretchPalette = function() {
  var checked, newPaletteLength;

  checked = $("#stretchPaletteCheckbox").attr("checked");
  if (stretchPalette === checked) {
    return;
  }
  stretchPalette = checked;
  newPaletteLength = (stretchPalette ? maxIterations : fixedPaletteLength);
  $("#paletteLengthPar").css("display", (stretchPalette ? "none" : "block"));
  if (newPaletteLength !== paletteLength) {
    createPalette();
    return startJob();
  }
};

changePaletteLength = function() {
  var len, val;

  val = $("#paletteLengthSelect").val();
  len = 0;
  if (val === "Other...") {
    val = prompt("Enter the palette length.", fixedPaletteLength);
    len = parseInt(val);
    if (isNaN(len) || len < 2 || len > 100000) {
      alert("Sorry, the value must be an integer, between 2 and 100000");
      $("#paletteLengthSelect").val(fixedPaletteLength);
      return;
    }
    $("#otherPaletteLength").html("(" + len + ")");
  } else {
    len = parseInt(val);
    $("#otherPaletteLength").html("&nbsp;");
  }
  if (len === fixedPaletteLength) {
    return;
  }
  fixedPaletteLength = len;
  if (fixedPaletteLength !== paletteLength) {
    createPalette();
    return startJob();
  }
};

DragBox.prototype.draw = function() {
  graphics.strokeStyle = "#FFF";
  graphics.strokeRect(this.left - 1, this.top - 1, this.width + 1, this.height + 1);
  graphics.strokeRect(this.left + 1, this.top + 1, this.width - 3, this.height - 3);
  graphics.strokeStyle = "#000";
  return graphics.strokeRect(this.left, this.top, this.width - 1, this.height - 1);
};

DragBox.prototype.setCorner = function(x1, y1) {
  if (x1 <= this.x) {
    this.left = x1;
    this.width = this.x - x1;
  } else {
    this.left = this.x;
    this.width = x1 - this.x;
  }
  if (y1 <= this.y) {
    this.top = y1;
    return this.height = this.y - y1;
  } else {
    this.top = this.y;
    return this.height = y1 - this.y;
  }
};

DragBox.prototype.zoom = function(zoomin) {
  var cx, cy, newHeight, newWidth, newXmax, newXmin, newYmax, newYmin, x1, x2, y1, y2;

  if (this.width <= 2 || this.height <= 2) {
    return;
  }
  stopJob();
  x1 = 0;
  x2 = 0;
  y1 = 0;
  y2 = 0;
  cx = 0;
  cy = 0;
  newWidth = 0;
  newHeight = 0;
  x1 = xmin + this.left / canvas.width * (xmax - xmin);
  x2 = xmin + (this.left + this.width) / canvas.width * (xmax - xmin);
  y1 = ymax - (this.top + this.height) / canvas.height * (ymax - ymin);
  y2 = ymax - this.top / canvas.height * (ymax - ymin);
  cx = (x1 + x2) / 2;
  cy = (y1 + y2) / 2;
  if (zoomin === false) {
    newXmin = xmin + (xmin - x1) / (x2 - x1) * (xmax - xmin);
    newXmax = xmin + (xmax - x1) / (x2 - x1) * (xmax - xmin);
    newYmin = ymin + (ymin - y1) / (y2 - y1) * (ymax - ymin);
    newYmax = ymin + (ymax - y1) / (y2 - y1) * (ymax - ymin);
    setLimits(newXmin, newXmax, newYmin, newYmax);
  } else {
    newWidth = x2 - x1;
    newHeight = y2 - y1;
    setLimits(cx - newWidth / 2, cx + newWidth / 2, cy - newHeight / 2, cy + newHeight / 2);
  }
  return startJob();
};

$(function() {
  if (!window.Worker) {
    $("#message").html("Sorry, your browser does not support worker threads.<br>" + "This page should work with recent versions of Firefox, Safari,<br>" + "Chrome, and Opera.  It will probably work in Internet Explorer 10.");
    return;
  }
  canvas = document.getElementById("mbcanvas");
  if (!canvas || !canvas.getContext) {
    $("#message").html("Sorry, your browser doesn't support the canvas element.");
    return;
  }
  graphics = canvas.getContext("2d");
  OSC = document.createElement("canvas");
  OSC.width = canvas.width;
  OSC.height = canvas.height;
  OSG = OSC.getContext("2d");
  graphics.fillStyle = "#BBB";
  createPalette();
  newWorkers(4);
  $("#restoreButton").click(setDefaults);
  $("#threadCountSelect").val("4");
  $("#threadCountSelect").change(changeWorkerCount);
  $("#maxIterSelect").val("100");
  $("#maxIterSelect").change(changeMaxIterations);
  $("#stretchPaletteCheckbox").attr("checked", true);
  $("#stretchPaletteCheckbox").change(changeStretchPalette);
  $("#paletteLengthSelect").val(fixedPaletteLength);
  $("#paletteLengthSelect").change(changePaletteLength);
  setUpDragging();
  return setDefaults();
});
